# 什麼是鏈表?

鏈表是一種通過指針串聯在一起的線性結構。每一個節點由兩部分組成，一個數據域一個指針域(存放指向下一個節點的指針)，最後一個節點的指針域指向null(空指針)

鏈表的入口節點稱為鏈表的頭節點(head)

![](https://camo.githubusercontent.com/2523dc7fdc7938125487503ae17b1226e2cab04ccbbf2f0884f6ec15620772a7/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230303830363139343532393831352e706e67)

---
## 鏈表的類型

+ 上圖就是單鏈表

+ 雙鏈表:
    
    - 單鏈表的指針域只能指向節點的下一個節點
    - 雙鏈表每一個節點有兩個指針域，一個指向下一個節點，一個指向上一個節點。雙鏈表既可以向前查詢，也可以向後查詢。
    
![](https://camo.githubusercontent.com/b39fd2c2fd6e503b91a3ecf0645c3fa9c0a35ca63edc45e5fbc31b2c9679d097/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230303830363139343535393331372e706e67)

+ 循環鏈表:

    鏈表首尾相連，循環鏈表可以用來解決約瑟夫環的問題。
    
![](https://camo.githubusercontent.com/7e5db49632c72cf28d98e9a61ea31244365b0ef472bc420d41cd15e713edd33c/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230303830363139343632393630332e706e67)

---
## 鏈表的存儲方式

數組內的儲存方式是連續的。而鏈表在內存中不是連續分布的。鏈表是通過指針域的指針鏈結在內存中各個節點。如圖所示:
![](https://camo.githubusercontent.com/d71e36f6f84c69e80a2249cdee7697b40c9c78cd33e5075dcb3dfb819e56c765/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230303830363139343631333932302e706e67)

---
## 鏈表的定義

在C/C++中定義鏈表節點的方式:

    // 單鏈表
    struct ListNode {
        int val;  // 節點尚存儲的元素
        ListNode *next;  // 指向下一個節點的指針
        ListNode(int x) : val(x), next(NULL) {}  // 節點的構造函數
    };

+ 自己定義構造函數初始化節點:

        ListNode* head = new ListNode(5);

+ 使用程式默認構造函數初始化節點:

        ListNode* head = new ListNode();
        head->val = 5;

如果不定義構造函數而使用默認構造函數的話，就無法在初始化時給予變量賦值。

---
## 鏈表的操作

+ 刪除節點

![](https://camo.githubusercontent.com/63d599ca32ca67d29b543da7aa2c43a6ef4c4ff1dbe3cd37ded5574d4208a50d/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230303830363139353131343534312d32303233303331303132313435393235372e706e67)

在C/C++裡刪除的節點需要手動釋放其記憶體，在Java、Python里內存自動回覆機制，不需要手動。

+ 添加節點

![](https://camo.githubusercontent.com/b4f9701f2782d7ffb949446c5d41f5c8829f33a19509a44343ef17e4370ed5e2/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230303830363139353133343333312d32303233303331303132313530333134372e706e67)

需要注意的是如果要刪除第5個節點，則必須要從 **頭節點(head)** 通過next指針進行刪除操作。

---

## 性能分析

比較數組和鏈表

![](https://camo.githubusercontent.com/6b19f34264e835fcf98a513e5803652a9f1a2ff9f3a37bb5fc2e00723b55e96f/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230303830363139353230303237362e706e67)